#Servlet 中文乱码问题

##Servlet中的request和response

服务器调用Servlet的时候会同时创建一个request和一个response对象。

- request用来存储客户端发送的请求
- response用来存储服务器返回的数据

##Servlet中处理字符编码问题

Servlet会把字符编码存储在response里，然后输出到浏览器中。所以这个问题可以从两个方面入手：

- Servlet的字符编码

```
    response.setCharacterEncoding("UTF-8");
```
- 浏览器的字符编码

```
    response.setHeader("Content-type", "text/html;charset=UTF-8");
```

但是有时候字符编码的这两条都设置了，浏览器中输出的为什么还是乱码呢？

有一个原因可能是你设置编码的代码在你声明的PrintWriter对象之后。
```
    //会有中文乱码问题
    PrinterWriter out = response.getWriter();
    response.setCharacterEncoding("UTF-8");
```
当然解决办法也很简单，把设置编码的代码调整到声明PrintWriter之前（使用ServletOutputStream则不受限制）。
另外setContentType 和 setCharacterEncoding两方法中设定characterEncoding的方法对服务器效果一致，不需要反复调用。
```
    //中文乱码问题解决
    response.setCharacterEncoding("UTF-8");
    PrinterWriter out = response.getWriter();
```
       
那PrintWriter是什么？
PrintWriter是字符流，它不能和ServletOutputStream字节流同时使用，同时使用会抛异常。

> 
    PrintWriter getWriter() throws IOException 
    
    Returns a PrintWriter object that can send character text to the client. The PrintWriter uses the character encoding returned by getCharacterEncoding(). 
  
    If the response's character encoding has not been specified as described in getCharacterEncoding (i.e., the method just returns the default value ISO-8859-1), getWriter updates it to ISO-8859-1. 

以上的意思是说PrinterWriter使用的字符编码是从getCharacterEncoding()来的。
就是讲，在返回一个PrintWriter对象的时候，character encoding就已经确定了，就已经设置好了字符集了。
什么时候设置的呢？
setCharacterEncoding()中设置的，从其中可以发现，如果已经调用了getWriter，那么set方法无效。

```

    public void setCharacterEncoding(String charset) {    
   
        if (isCommitted())    
            return;
            
        // Ignore any call from an included servlet    
        if (included)    
            return;
            
        // Ignore any call made after the getWriter has been invoked    
        // The default should be used    
        if (usingWriter)    
            return;
   
        coyoteResponse.setCharacterEncoding(charset);    
        isCharacterEncodingSet = true;
    }  
```




