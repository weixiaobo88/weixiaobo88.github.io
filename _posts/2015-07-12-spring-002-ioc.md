#开始学习Spring 

##Spring 4 IoC

Spring 4.0.2 有20个modules，打包成20个jar文件

任何一个有实际意义的应用都是由两个或者更多的类组成，这些类相互之间进行协作来完成特定的业务逻辑。通常，每个对象负责管理与自己相互协作的对象（即它所以来的对象）的引用，这将会导致高度耦合和难以测试的代码。

通过依赖注入，对象的依赖关系将由负责协调系统中各个对象的第三方组件在创建对象时设定。对象无需自行创建或管理它们的依赖关系——依赖关系将被自动注入到需要它们的对象中去。


##控制反转
一个需要特定依赖的组件，我们称为依赖对象dependent object，或者在IoC中称为目标target。

通常来讲， IoC有两种类型：

- Dependency Lookup 
    * Dependency Pull 依赖拖拽，组件之间的依赖关系是根据需要，从一个集中的“仓库”中获取的。
    * Contextualized Dependency Lookup (CDL) 上下文配置依赖查找，在当前运行的容器所管理的资源中进行查找。
- Dependency Injection 
    * Constructor 构造函数依赖注入
    * Setter Dependency Injection setter方法依赖注入

依赖注入的真正价值在于把相互协作的对象装配在一起，而不需要这些对象自己负责装配。
Spring提倡面向接口编程，面向接口编程与依赖注入协作实现了松散耦合。

### 注入 vs. 查找

- 查找，应用必须依赖于特定容器的特定类或者接口，程序就与特定的容器想耦合，移植性大打折扣
- 注入，不用手工配置查找的代码，组件之间的灵活性高，不需要主动调用相应的魔豆，对象都会保存在同一的地方

### setter注入 vs. 构造器注入

- 构造函数注入，应用在要使用组件之前就必须要实例化被依赖的组件的情况下。
- setter注入，应用在组件本身对容器暴露自身的依赖关系，并且愿意提供一个默认的依赖关系的情况下。
 
##Spring中的IoC
在基于Spring的应用中，偏向使用依赖注入而不是查找，但是对于独立对象的访问，怡然需要通过查找来获取合作关系。
Spring还不能自动将应用程序组件通过依赖注入连接起来，因此必须通过依赖查找来初始化组件集合。

使用Spring MVC来构建Web应用的时候，反而不会遇到这种麻烦事，Spring此时就像一个粘合剂，很好的粘合了应用的各个部分。

Spring IoC体现在：

- Setter注入
- Constructor注入
- Method注入
- autowiring
- bean inheritance

##Spring中的DI

Spring DI 容器的核心是 BeanFactory 接口


要做两件事：

- 在程序中使用BeanFactory
- 配置BeanFactory

在Spring中，ApplicationContext接口是BeanFactory的扩展，ApplicationContext除了提供DI服务之外，还有其他，比如事务、AOP、事件处理等。

在开发过程中，推荐使用ApplicationContext与Spring进行交互。

###配置ApplicationContext

定义beans的方式：

- properties
- XML文件
    * 配置文件在Java code之外
- Java annotations (始于Spring 2.5)
    * 运行开发人员定义和查看DI setup
    
Spring也支持在同一个ApplicationContext中采用XML文件和annotation的混合配置方式。
一种通用的方式是在XML文件中定义应用的基础设施（比如，data source，transaction manager，JMS connection factory，JMX），
使用annotation来定义DI配置（注入的bean和bean的依赖）

####XML文件配置方式
需要声明所需要的Spring命名空间beans

```样例 app-context-xml.xml

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="messageProvider"
              class="com.apress.prospring4.ch3.xml.HelloWorldMessageProvider"/>
    </beans>

```

####annotation配置方式

需要在XML文件中声明tags

```样例 app-context-annotation.xml

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">
        <context:component-scan base-package="com.apress.prospring4.ch3.annotation" />
    </beans>
```
<context:component-scan> 标签告诉Spring在所配置的包中扫描注入的beans，这些bean通过注解 @Component, @Controller, @Repository, and @Service， @Autowired and @Inject标明。
在<context:component-scan> 标签中可以定义多个packages，使用逗号、分号或空格来分隔开。该标签还可以指定包含或排除某个component。

###使用XML实现Setter注入
使用XML来配置Setter注入，需要在<bean>下配置一个<property>的标签，每个<property>表示一个要注入的依赖。

```

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
              http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="messageRenderer"
            class="com.apress.prospring4.ch3.xml.StandardOutMessageRenderer">
            <property name="messageProvider" ref="messageProvider"/>
        </bean>
        或者可以用“p”的命名空间
        <bean id="messageRenderer"
            class="com.apress.prospring4.ch3.xml.StandardOutMessageRenderer"
            p:messageProvider-ref="messageProvider"/>
            
        <bean id="messageProvider"
            class="com.apress.prospring4.ch3.xml.HelloWorldMessageProvider"/>
    </beans>

```
命名空间“p”没有定义在XSD文件中，只存在于Spring core中，所以在schemaLocation属性中没有对于的XSD。

###使用annotation实现setter注入
只需要添加@Autowired

```

    @Service("messageRenderer")
    public class StandardOutMessageRenderer implements MessageRenderer {
        private MessageProvider messageProvider;
        
        @Override
        @Autowired
        public void setMessageProvider(MessageProvider provider) {
            this.messageProvider = provider;
        }
    }

```
在XMl文件中配置了 <context:component-scan> ，在Spring的ApplicationContext初始化的时候，会找到所有的@Autowired的annotation，并注入所需的依赖。

###使用XML来配置构造函数注入

在XML文件中使用<constructor-arg>，同时采用value的属性为构造函数传递参数。如果参数多于一个，可以使用index属性来指定参数的顺序。
同时也可以使用命名空间“c”来代替。“c”也是只存在于Spring core中。
```

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
              http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="messageProvider"
            class="com.apress.prospring4.ch3.xml.ConfigurableMessageProvider">
            <constructor-arg value="Configurable message"/>
        </bean>
        或者
        <bean id="messageProvider"
            class="com.apress.prospring4.ch3.xml.ConfigurableMessageProvider"
            c:message="This is a configurable message"/>
    </beans>
```
如果需要传递的参数是整型的话，需要指明类型：

```

    <bean id="constructorConfusion"
            class="com.apress.prospring4.ch3.xml.ConstructorConfusion">
        <constructor-arg type=”int”>
            <value>90</value>
        </constructor-arg>
    </bean>
```
###使用annotation来配置构造函数注入
在构造函数上声明@Autowired。

```

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xmlns:c="http://www.springframework.org/schema/c"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
              http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/context
              http://www.springframework.org/schema/context/spring-context.xsd">
    
        <context:component-scan
              base-package="com.apress.prospring4.ch3.annotation"/>
        <bean id="message" class="java.lang.String" c:_0="This is a configurable message"/>
    </beans>
```

###参数注入
####简单类型的值
###方法注入



##参考资料
《Pro Spring 4 Edition》



